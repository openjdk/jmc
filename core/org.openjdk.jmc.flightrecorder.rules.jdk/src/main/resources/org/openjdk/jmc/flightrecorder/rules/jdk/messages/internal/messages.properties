#
#  Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
#
#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
#  The contents of this file are subject to the terms of either the Universal Permissive License
#  v 1.0 as shown at http://oss.oracle.com/licenses/upl
#
#  or the following license:
#
#  Redistribution and use in source and binary forms, with or without modification, are permitted
#  provided that the following conditions are met:
#
#  1. Redistributions of source code must retain the above copyright notice, this list of conditions
#  and the following disclaimer.
#
#  2. Redistributions in binary form must reproduce the above copyright notice, this list of
#  conditions and the following disclaimer in the documentation and/or other materials provided with
#  the distribution.
#
#  3. Neither the name of the copyright holder nor the names of its contributors may be used to
#  endorse or promote products derived from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
Preference_SHORT_RECORDING=Short recording limit
Preference_SHORT_RECORDING_LONG=Minimum length of a recording to be considered useful for rules to work on.

AllocationByClassRule_RULE_NAME=Allocated Classes
# {0} is a class name
AllocationByClassRule_TEXT_MESSAGE=The most allocated type is likely ''{0}'', most commonly allocated by: {1}
AllocationByThreadRule_RULE_NAME=Threads Allocating
# {0} is a thread name
AllocationByThreadRule_TEXT_MESSAGE=The most allocations were likely done by thread ''{0}'' at: {1}
AllocationRuleFactory_TEXT_CLASS_INFO_LONG=Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.
AllocationRuleFactory_TEXT_THREAD_INFO_LONG=Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.
ApplicationHaltsRule_HALTS_INFO_LIMIT=Application halts info limit
ApplicationHaltsRule_HALTS_INFO_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger an info notice
ApplicationHaltsRule_HALTS_WARNING_LIMIT=Application halts warning limit
ApplicationHaltsRule_HALTS_WARNING_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger a warning
ApplicationHaltsRule_HALTS_WINDOW_SIZE=Application halts time window size
ApplicationHaltsRule_HALTS_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
# {0} is a concatenated string of event type ids
ApplicationHaltsRule_EXTRA_EVENT_TYPES=Enabling the following event types would improve the accuracy of this rule: {0}
ApplicationHaltsRule_RULE_NAME=Application Halts
ApplicationHaltsRule_RULE_TEXT=Application efficiency was affected by halts
# {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
ApplicationHaltsRule_RULE_TEXT_LONG=The highest ratio of application halts to execution time was {0} % for {1} at {2}. {3} % of the halts were for reasons other than GC.<p>The halts ratio for the entire recording was {4} %. {5} % of the total halts were for reasons other than GC.</p>
ApplicationHaltsRule_RULE_TEXT_RECOMMENDATION=Application halts are often caused by garbage collections, but can also be caused by excessive thread dumps or heap dumps. Investigate the VM Operation information and possibly the safepoint specific information.
ApplicationHaltsRule_RULE_TEXT_OK=Application efficiency was not highly affected by halts.

AutoboxingRule_RULE_NAME=Primitive To Object Conversion
AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT=Primitive to object conversion allocation ratio info limit
AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT_DESC=The ratio between allocation caused by primitive to object conversion compared to the total allocation needed to trigger an info notice.
AutoboxingRule_AUTOBOXING_RATIO_WARNING_LIMIT=Primitive to object conversion allocation ratio warning limit
AutoboxingRule_AUTOBOXING_RATIO_WARNING_LIMIT_DESC=The ratio between allocation caused by primitive to object conversion compared to the total allocation needed to trigger a warning.
AutoboxingRule_RESULT_NO_AUTOBOXING=No allocation was caused by conversion from primitive types to the corresponding object types.
# {0} is a type name
AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE=The most common object type that primitives are converted into is ''{0}''.
# {0} is a type name, {1} is a size in bytes, {2} is a method reference string
AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE_LONG=The most common object type that primitives are converted into is ''{0}'', which causes {1} to be allocated. The most common call site is ''{2}''.
AutoboxingRule_RESULT_AUTOBOXING_RATIO={0} % of the total allocation ({1}) is caused by conversion from primitive types to object types.
AutoboxingRule_RESULT_LONG=Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.
BiasedLockingRevocationRule_CONFIG_FILTERED_CLASSES=Filtered Classes
BiasedLockingRevocationRule_CONFIG_FILTERED_CLASSES_LONG=A comma separated list of the class names not to report
BiasedLockingRevocationRule_CONFIG_WARNING_LIMIT=Revocation warning limit
BiasedLockingRevocationRule_CONFIG_WARNING_LIMIT_LONG=The number of revocations at which to start warning
BiasedLockingRevocationRule_NAME=Biased Locking Revocation
BiasedLockingRevocationRule_TEXT_OK=No classes were disabled from participating in biased locking
BiasedLockingRevocationRule_TEXT_REVOKED_CLASSES_FOUND=Fully revoked classes found.
BiasedLockingRevocationRule_TEXT_REVOKED_CLASSES_FOUND_LONG=The following classes were disabled from using biased locking:
BiasedLockingRevocationRule_TEXT_REVOKE_LIMIT_CLASSES_FOUND=Instances of classes were revoked more times than the user configured limit.
# {0} is the user configured revocation limit
BiasedLockingRevocationRule_TEXT_REVOKE_LIMIT_CLASSES_FOUND_LONG=The following instances of classes were revoked more than the user configured limit for this rule (limit={0}, not including disabled classes):
# {0} is the classes that were filtered out from the result.
BiasedLockingRevocationRule_TEXT_EPILOGUE=<p>Biased locking is a technique used by the JVM to decrease the cost of uncontended locking to near lock free performance. A thread can bias a lock object to itself, making subsequent locking by the same thread very inexpensive. If the lock starts being used by other threads, the bias can either be revoked, rebiased towards the other thread, or revoked from being biased again for the rest of the runtime of the JVM.</p><p>Having a lot of revoked classes need not be a problem, but can provide opportunities for optimizations, tuning and design improvements. For example, if you have a lot of contention during the startup of your application, the revocation costs may be significant, and you may want to delay the enablement of biased locking using the ''-XX:BiasedLockingStartupDelay=&lt;time in ms&gt;'' flag. For applications that heavily depend on contended locking, and cannot be redesigned, it may be beneficial to turn off biased locking altogether (''-XX:-UseBiasedLocking''). For benchmarking, you may want to set ''-XX:BiasedLockingStartupDelay'' to zero.<p><p>The following classes were filtered out: {0}</p>
BiasedLockingRevocationPauseRule_CONFIG_WARNING_LIMIT=Biased locking warning limit time
BiasedLockingRevocationPauseRule_CONFIG_WARNING_LIMIT_LONG=The total time spent on revoking biased locks needed to trigger a warning
BiasedLockingRevocationPauseRule_RULE_NAME=Biased Locking Revocation Pauses
BiasedLockingRevocationPauseRule_TEXT_INFO_LONG=To avoid this, either turn off biased Locking ('-XX:-UseBiasedLocking') or, if this occurs during startup, delay the use of biased Locking ('-XX:BiasedLockingStartupDelay').
# {0} is a time period
BiasedLockingRevocationPauseRule_TEXT_MESSAGE=The total time spent revoking biased locks was {0}.
BiasedLockingRevocationPauseRule_TEXT_OK=No revocation of biased locks found.
BufferLostRuleFactory_CONFIG_WARN_LIMIT=Buffer lost limit
BufferLostRuleFactory_CONFIG_WARN_LIMIT_LONG=The number of lost buffer events needed to trigger a warning
BufferLostRuleFactory_RULE_NAME=Lost Flight Recorder Buffers
BufferLostRuleFactory_RULE_TEXT_OK=No Flight Recorder buffers were lost during the recording.
# {0} is a number, {1} is a size in bytes
BufferLostRuleFactory_TEXT_INFO={0} Flight Recorder event buffer(s) with a total size of {1} were lost.
# {0} is a number, {1} is a size in bytes, {2} is a time stamp
BufferLostRuleFactory_TEXT_INFO_LONG={0} Flight Recorder event buffer(s) were lost. The total size of the lost data was {1}, with the first lost buffer occurring at {2}. Buffers with events are dropped when there is an abnormally high pressure on the Flight Recorder. Avoid this by reducing the number of events recorded, especially for event types with high event rates and/or large payloads.
ClassLeakingRule_CONFIG_WARNING_LIMIT=Warning limit
ClassLeakingRule_CONFIG_WARNING_LIMIT_LONG=Number of loads of a class to issue a warning.
ClassLeakingRule_NAME=Class Leak
ClassLeakingRule_TEXT_OK=No classes with identical names have been loaded more times than the limit.
# {0} is the class, {1} is the number of time it was loaded
ClassLeakingRule_TEXT_WARN=The difference between the number of times a class has been loaded and the number it has been unloaded, has exceeded the user specified limit. Most loaded: {0} ({1})
# {0} is the number of classes exceeding the limit
ClassLeakingRule_TEXT_WARN_LONG=Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak.<p>Top {0} loaded classes:</p>
ClassLoadingRule_CONFIG_DURATION_LIMIT=Classloading duration limit
ClassLoadingRule_CONFIG_DURATION_LIMIT_LONG=The shortest classloading duration that should trigger a warning
ClassLoadingRule_CONFIG_RATIO_LIMIT=Classloading ratio limit
ClassLoadingRule_CONFIG_RATIO_LIMIT_LONG=The minimum ratio between time spent in classloading and the total duration of the recording
ClassLoadingRuleFactory_RULE_NAME=Class Loading Pressure
ClassLoadingRuleFactory_RULE_TEXT_OK=No significant time was spent loading new classes during this recording.
ClassLoadingRuleFactory_TEXT_INFO={0} was spent loading {1} new classes during this recording.
ClassLoadingRuleFactory_TEXT_INFO_LONG={0} was spent loading {1} new classes during this recording. The longest class loading event took {2}.<p>If the recording occurred during the warm-up phase of the application, this is to be expected. If not, it might be good to check why these classes were being loaded.
CodeCacheRuleFactory_DEFAULT_LONG_DESCRIPTION=If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. To avoid this, either increase the size of the code cache ('-XX:ReservedCodeCacheSize') or increase the compilation threshold ('-XX:CompileThreshold').
CodeCacheRuleFactory_JDK8_TEXT_WARN=The code cache was around {0} free during the recording. This could potentially become an issue.
CodeCacheRuleFactory_RULE_NAME=Code Cache
CodeCacheRuleFactory_BLOG_REFERENCE=See <a href="https://blogs.oracle.com/poonam/why-do-i-get-message-codecache-is-full-compiler-has-been-disabled">this blog post</a> for a longer discussion on the code cache.
CodeCacheRuleFactory_SIZE_INFO_LIMIT=Code cache occupancy info limit
CodeCacheRuleFactory_SIZE_INFO_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return an Info result
CodeCacheRuleFactory_SIZE_WARN_LIMIT=Code cache occupancy warning limit
CodeCacheRuleFactory_SIZE_WARN_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return a Warning result
CodeCacheRuleFactory_TEXT_OK=No problems with the code cache were detected in the recording.
CodeCacheRuleFactory_TEXT_WARN=The code cache was filled during this recording.
CodeCacheRuleFactory_TEXT_WARN_LONG=This can happen if you have a lot of code in your application or if the code cache is too small. If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. Increase the size of the code cache with '-XX:ReservedCodeCacheSize', for example '-XX:ReservedCodeCacheSize=128M'.
CodeCacheRuleFactory_WARN_LONG_DESCRIPTION=This causes the code cache to be swept more frequently, with even higher occupancy causing more frequent sweeps.
CodeCacheRuleFactory_WARN_SEGMENTED_HEAP_SHORT_DESCRIPTION=The {0} code heap reached more than 50 % occupancy during the recording.
CodeCacheRuleFactory_WARN_SEGMENTED_HEAPS_SHORT_DESCRIPTION=The {0} code heaps reached more than 50 % occupancy during the recording.
CompareCpuRule_RULE_NAME=Competing CPU Ratio Usage
CompareCpuRule_TEXT_INFO_LONG=The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.
CompareCpuRule_TEXT_TOO_FEW_SAMPLES=Not enough samples available to calculate result.
# {0} is a time period, {1} is a time stamp, {2} is a percentage
CompareCpuRule_TEXT_MESSAGE=An average CPU load of {2} was caused by other processes for {0} at {1}.
CompareCpuRule_INFO_LIMIT=Competing CPU Ratio usage info limit
CompareCpuRule_INFO_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger an info notice
CompareCpuRule_WARNING_LIMIT=Competing CPU Ratio usage warning limit
CompareCpuRule_WARNING_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger a warning
CompressedOopsRuleFactory_RULE_NAME=Compressed Oops
CompressedOopsRuleFactory_TEXT_INFO=The Java Heap Size is below 32 GB and Compressed Oops is turned off.
CompressedOopsRuleFactory_TEXT_INFO_LONG=Not using Compressed Ordinary Object Pointers when the heap size is below 32 GB wastes memory and will lead to unnecessary cache pressure. Use the JVM argument '-XX:+UseCompressedOops' to enable this feature.
CompressedOopsRuleFactory_TEXT_OK=The settings for Compressed Oops were OK.
ConcurrentFailedRuleFactory_TEXT_WARN=There occurred Concurrent Mode failures during certain garbage collections.
ConcurrentFailedRuleFactory_TEXT_WARN_LONG=Concurrent Mode failures means that the Garbage Collector hasn't been able to keep up with the Java Program. Try lowering the value of <a href="http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html">-XX:InitiatingHeapOccupancyPercent</a>.
ContextSwitchRule_AGGR_MAX_BLOCKS=Max Blocks
ContextSwitchRule_CONFIG_WARNING_LIMIT=Context switch rate warning limit
ContextSwitchRule_CONFIG_WARNING_LIMIT_LONG=The context switch rate (switches/second) needed to trigger a warning
ContextSwitchRuleFactory_RULE_NAME=Context Switches
ContextSwitchRuleFactory_TEXT_INFO=The program causes many context switches during the recording.
ContextSwitchRuleFactory_TEXT_INFO_LONG=The program context switched a lot and many threads waited on the same monitor. Consider using fewer threads, or decreasing lock contention by other means.
ContextSwitchRuleFactory_TEXT_OK=The program did not context switch excessively during the recording.
DMSIncidentRule_AGGR_INCIDENTS_COUNT=DMS Incidents
DMSIncidentRule_AGGR_INCIDENTS_COUNT_DESC=The number of DMS incidents
DMSIncidentRule_CONFIG_WARNING_LIMIT=DMS incident warning limit
DMSIncidentRule_CONFIG_WARNING_LIMIT_LONG=The number of DMS incidents needed to trigger a warning
DMSIncidentRuleFactory_RULE_NAME=DMS Incidents
DMSIncidentRuleFactory_TEXT_OK=No DMS Incidents were reported in the recording.
DMSIncidentRuleFactory_TEXT_WARN=There were reported DMS incidents.
# {0} is a number
DMSIncidentRuleFactory_TEXT_WARN_LONG=There are {0} reported DMS (Dynamic Monitoring Service) incidents.
DeprecatedGcRuleFactory_TEXT_WARN_PERMGEN_LONG=PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">MaxMetaspaceSize flag</a>.
DumpReason_RULE_NAME=Exceptional Dump Reason
DumpReasonRule_TEXT_OK=This recording was not dumped for an exceptional reason.
DumpReasonRule_TEXT_INFO=This recording was dumped for an exceptional reason.
DumpReasonRule_TEXT_LONG_CRASH=Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.
DumpReasonRule_TEXT_LONG_OOM=Recording was dumped due to an out of memory. Some events are likely missing from the end of the recording.
DumpReasonRule_TEXT_LONG_COREDUMP=Recording was extracted from a core dump.
DumpReasonRule_TEXT_INFO_UNKNOWN=This recording was dumped for an unknown, likely not exceptional, reason.
DumpReasonRule_TEXT_LONG_UNKNOWN=Recording was dumped for reason: {0}.
DumpReasonRule_CRASH_SCORE=Crash score
DumpReasonRule_CRASH_SCORE_LONG=Score for recording dumped due to crash
DumpReasonRule_OOM_SCORE=OOM score
DumpReasonRule_OOM_SCORE_LONG=Score for recording dumped due to out of memory
DumpReasonRule_COREDUMP_SCORE=Core dump score
DumpReasonRule_COREDUMP_SCORE_LONG=Score for recording extracted from core dump
DuplicateFlagsRuleFactory_RULE_NAME=Duplicated Flags
DuplicateFlagsRuleFactory_TEXT_OK=There were no duplicate JVM flags on the command line.
DuplicateFlagsRuleFactory_TEXT_WARN_SINGULAR=One JVM flag was duplicated.
# {0} is a number
DuplicateFlagsRuleFactory_TEXT_WARN=There were {0} JVM duplicated flags.
# {0} is an HTML list of duplicated JVM flags
DuplicateFlagsRuleFactory_TEXT_WARN_LONG=Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. Try to find all the places where the flag is defined and keep only one. The following flags were duplicated: {0}
ErrorRule_CONFIG_INFO_LIMIT=Error rate info limit
ErrorRule_CONFIG_INFO_LIMIT_LONG=The number of error events per minute needed to trigger an info notice
ErrorRule_CONFIG_WARN_LIMIT=Error rate warning limit
ErrorRule_CONFIG_WARN_LIMIT_LONG=The number of error events per minute needed to trigger a warning
ErrorRule_CONFIG_EXCLUDED_ERRORS=Excluded error classes
ErrorRule_CONFIG_EXCLUDED_ERRORS_LONG=Regular expression describing which error classes to exclude, for example (com.sun.el.parser.ELParser\\$LookaheadSuccess|java.lang.NoSuchMethodError)
ErrorRule_CONFIG_WINDOW_SIZE=Sliding window size
ErrorRule_CONFIG_WINDOW_SIZE_LONG=The size of the sliding window used to find periods with many errors per minute.
ErrorRule_RULE_NAME=Thrown Errors
ErrorRule_TEXT_OK=The program did not generate any Errors.
# {0} is a number, {1} is a time range
ErrorRule_TEXT_WARN=The program generated an average of {0} errors per minute during {1}.
# {0} is a number, {1} is a time range, {2} is a number, {3} is an error class name, {4} is a number
ErrorRule_TEXT_WARN_LONG=The program generated an average of {0} errors per minute during {1}. {2} errors were thrown in total.<p>The most common error was ''{3}'', which was thrown {4} times.<p>Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control.
# {0} is a regexp exclude string, {1} is a number
ErrorRule_TEXT_WARN_EXCLUDED_INFO=The following regular expression was used to exclude {1} errors from this rule: ''{0}''.
ExceptionRule_CONFIG_INFO_LIMIT=Exception rate info limit
ExceptionRule_CONFIG_INFO_LIMIT_LONG=The number of thrown exceptions per second needed to trigger an info notice
ExceptionRule_CONFIG_WARN_LIMIT=Exception rate warning limit
ExceptionRule_CONFIG_WARN_LIMIT_LONG=The number of thrown exceptions per second needed to trigger a warning
ExceptionRule_RULE_NAME=Thrown Exceptions
ExceptionRule_TEXT_INFO_LONG=Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.
# {0} is a time period, {1} is a time stamp, {2} is a number
ExceptionRule_TEXT_MESSAGE=The program generated {2} exceptions per second for {0} at {1}.
FatalErrorRule_RULE_NAME=Fatal Errors
FatalErrorRule_TEXT_OK=The JVM shut down in a normal way.
FatalErrorRule_TEXT_INFO=The JVM shut down due to there being no remaining non-daemon Java threads.
FatalErrorRule_TEXT_WARN=The JVM shut down due to a fatal error. This indicates that the program terminated in an abnormal way and should be investigated.
FasttimeRule_TEXT_WARN=This Flight Recording was made with a JVM with a bug in the Fast Time conversion.
FasttimeRule_TEXT_WARN_LONG=The timestamps in this recording are unreliable and may not represent the actual data properly or it may cause problems for JMC. Upgrade to Java 7u60 or later to resolve this issue.
FewSampledThreadsRule_AGGR_SAMPLES_PER_THREAD=Samples per thread
FewSampledThreadsRule_AGGR_SAMPLES_PER_THREAD_DESC=Samples per thread
# {0} is a percentage, {1} a time period, {2} a timestamp.
FewSampledThreadsRule_APPLICATION_IDLE=The application seems to be idle. JVM CPU usage was {0} % for {1} at {2}.
FewSampledThreadsRule_APPLICATION_IDLE_LONG=This may be caused by application latencies, see information from other rules, or it could be that the application is not doing anything.
FewSampledThreadsRule_CPU_WINDOW_SIZE=CPU window size
FewSampledThreadsRule_CPU_WINDOW_SIZE_LONG=Sliding window size used when calculating CPU usage.
FewSampledThreadsRule_MIN_CPU_RATIO=Min used CPU ratio
FewSampledThreadsRule_MIN_CPU_RATIO_LONG=The minimum used CPU ratio to consider this application not being idle.
FewSampledThreadsRule_MIN_SAMPLE_COUNT=Min total sample count
FewSampledThreadsRule_MIN_SAMPLE_COUNT_LONG=Minimum number of samples in recording for this rule to be applicable.
FewSampledThreadsRule_MIN_SAMPLE_COUNT_PER_THREAD=Min sample count per thread
FewSampledThreadsRule_MIN_SAMPLE_COUNT_PER_THREAD_LONG=Minimum number of samples in a thread to consider the thread as sampled.
FewSampledThreadsRule_SAMPLED_THREADS_RATIO_WARNING_LIMIT=Sampled threads ratio limit
FewSampledThreadsRule_SAMPLED_THREADS_RATIO_WARNING_LIMIT_LONG=Ratio between sampled threads and hardware threads needed to trigger a warning.
FewSampledThreadsRule_TEXT_OK=There were no problems with the amount of sampled threads.
FewSampledThreadsRule_TEXT_OK_LONG=There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.
# {0} and {1} are numbers
FewSampledThreadsRule_TEXT_NOT_ENOUGH_SAMPLES=There are only {0} method profiling samples in the recording. This rule needs at least {1} samples to be useful.
FewSampledThreadsRule_RULE_NAME=Parallel Threads
FewSampledThreadsRule_TEXT_INFO=There are fewer sampled threads than the total number of hardware threads (cores).
# {0} is a count, {1} is a count, {2} is a count
FewSampledThreadsRule_TEXT_INFO_LONG={1} threads with at least {0} method samples were found, but the machine has {2} hardware threads (cores). The application might benefit from a higher level of parallelism. This could also be caused by threads doing something else than running Java code, for example running native code or spending time in the JVM internals.
FileReadRule_CONFIG_WARNING_LIMIT=File read duration warning limit
FileReadRule_CONFIG_WARNING_LIMIT_LONG=The shortest file read duration that should trigger a warning
FileReadRuleFactory_RULE_NAME=File Read Peak Duration
# {0} is a time period
FileReadRuleFactory_TEXT_OK=No long file read pauses were found in this recording (the longest was {0}).
FileReadRuleFactory_TEXT_NO_EVENTS=There are no file read events in this recording.
# {0} is a time period
FileReadRuleFactory_TEXT_WARN=There are long file read pauses in this recording (the longest is {0}).
# {0} is a time period, {1} is a time stamp, {2} is a size in bytes
FileReadRuleFactory_TEXT_WARN_LONG=The longest recorded file read took {0} to read {2} from {1}.
FileWriteRule_CONFIG_WARNING_LIMIT=File write duration warning limit
FileWriteRule_CONFIG_WARNING_LIMIT_LONG=The shortest file write duration that should trigger a warning
FileWriteRuleFactory_RULE_NAME=File Write Peak Duration
# {0} is a time period
FileWriteRuleFactory_TEXT_OK=No long file write pauses were found in this recording (the longest was {0}).
FileWriteRuleFactory_TEXT_NO_EVENTS=There are no file write events in this recording.
# {0} is a time period
FileWriteRuleFactory_TEXT_WARN=There are long file write pauses in this recording (the longest is {0}).
# {0} is a time period, {1} is a time stamp, {2} is a size in bytes
FileWriteRuleFactory_TEXT_WARN_LONG=The longest recorded file write took {0} to write {2} to {1}.
FlightRecordingSupportRule_RULE_NAME=Flight Recording Support
FlightRecordingSupportRule_TEXT_OK=The JVM version used for this recording has full Flight Recorder support.
FlightRecordingSupportRule_EA_TEXT_WARN_SHORT=The recording is from an early access build.
FlightRecordingSupportRule_EA_TEXT_WARN_LONG=This recording is from an early access build of the JRE ({0}). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.
FlightRecordingSupportRule_NO_JVM_VERSION_EVENTS_TEXT=There were no VM information events with JVM version information recorded. Please turn on JVM information events to use this rule.
FlightRecordingSupportRule_UNSUPPORTED_TEXT_WARN_SHORT=The recording is from an unsupported JRE version.
FlightRecordingSupportRule_UNSUPPORTED_TEXT_WARN_LONG=This recording is from a runtime with JRE version {0}, before JDK Flight Recorder was fully supported in HotSpot. Versions before 7u40 only have partial support for flight recordings. The automated analysis is not supported, and you may see errors when attempting to analyze this recording.

FullGcRule_RULE_NAME=G1/CMS Full Collection
FullGcRule_OTHER_COLLECTOR_IN_USE=This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.
FullGcRule_FULL_GC_OCCURRED_TITLE=Full GC detected.
FullGcRule_FULL_GC_OCCURRED_DESC=At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.
FullGcRule_NO_FULL_GC_OCCURRED=No Stop-the-World, Full GC events detected.

GcFreedRatioRule_RULE_NAME=GC Freed Ratio
GcFreedRatioRule_GC_FREED_RATIO_INFO_LIMIT=Memory freed per second compared to liveset size info limit
GcFreedRatioRule_GC_FREED_RATIO_INFO_LIMIT_DESC=Ratio between the amount of memory freed by garbage collections per second compared to the liveset needed to trigger an info notice.
GcFreedRatioRule_WINDOW_SIZE=Time window size
GcFreedRatioRule_WINDOW_SIZE_DESC=The time window size to use when evaluating the rule.
GcFreedRatioRule_FEW_GCS_LIMIT=Too few garbage collections limit
GcFreedRatioRule_FEW_GCS_LIMIT_DESC=Minimum number of garbage collections for rule calculations to be relevant.
# {0} is a count, # {1} is a count
GcFreedRatioRule_RESULT_FEW_GCS=Only {0} heap summary events were found, this rule requires at least {1} events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.
GcFreedRatioRule_RESULT_OK=This is likely a reasonable amount.
GcFreedRatioRule_RESULT_NOT_OK=This may be excessive.
# {0} is a number
GcFreedRatioRule_RESULT_SHORT_DESCRIPTION=The ratio between memory freed by garbage collections per second and liveset is {0}.
# {0} is a memory amount, {1} is a timespan, {2} is a timestamp, {3} is a number, {4} is a memory amount
GcFreedRatioRule_RESULT_LONG_DESCRIPTION={0} per second was freed by garbage collections for {1} at {2}. This is {3} times the average liveset which was {4}.
GcFreedRatioRule_RESULT_MORE_INFO=If the garbage collector can free a lot of memory, it may be because the application allocates a lot of short lived objects. Investigate the allocation stack traces to see which code paths cause the most allocations, and see if they can be reduced.

GcPauseRatioRule_INFO_LIMIT=GC pause ratio info limit
GcPauseRatioRule_INFO_LIMIT_DESC=Ratio between GC pauses and execution time within a time window needed to trigger an info notice
GcPauseRatioRule_WARNING_LIMIT=GC pause ratio warning limit
GcPauseRatioRule_WARNING_LIMIT_DESC=Ratio between GC pauses and execution time within a time window needed to trigger a warning
GcPauseRatioRule_WINDOW_SIZE=GC pause time window size
GcPauseRatioRule_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
GcPauseRatioRule_RULE_NAME=GC Pauses
GcPauseRatioRule_RULE_TEXT=Application efficiency was affected by GC pauses.
# {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
GcPauseRatioRule_RULE_TEXT_LONG=The highest ratio between garbage collection pauses and execution time was {0} % for {1} at {2}. The garbage collection pause ratio of the entire recording was {3} %.
GcPauseRatioRule_RULE_TEXT_RECOMMENDATION=Pause times may be reduced by increasing the heap size or by trying to reduce allocation.
GcPauseRatioRule_RULE_TEXT_OK=Application efficiency was not highly affected by GC pauses.

GcLockerRule_CONFIG_WARNING_LIMIT=GC locker ratio limit
GcLockerRule_CONFIG_WARNING_LIMIT_LONG=Warning limit ratio between number of garbage collections caused by GC locker and total garbage collections
GcLockerRule_TEXT_NA=No GC information events found.
GcLockerRuleFactory_RULE_NAME=GCs Caused by GC Locker
# {0} is a percentage
GcLockerRuleFactory_TEXT_INFO={0} of the garbage collections were affected by GC Locker.
GcLockerRuleFactory_TEXT_INFO_LONG=Garbage collections affected by GC Locker indicates that the runtime ran JNI code (using JNI Get*Critical) to (possibly) gain direct access to a string or an array. Some garbage collectors will need the object to be released before being able to proceed. If this becomes a big problem, either avoid relying on (JNI) code requiring this behavior or switch to a garbage collection algorithm which handles this more graciously (for example pinning the object or pinning the memory region wherein it is located).
GcLockerRuleFactory_TEXT_OK=No GCs were affected by the GC Locker.
GcStallRule_RULE_NAME=GC Stall
GcStallRule_TEXT_OK=No indications that the garbage collector could not keep up with the workload were detected.
General_CONFIG_CLASS_LIMIT=Class limit
General_CONFIG_CLASS_LIMIT_LONG=The maximum number of classes exceeding the Warning Limit to report.
General_NO_STACK_TRACE_AVAILABLE=<p>&lt;No stack trace available&gt;</p>
General_RULE_REQUIRES_EVENTS_FROM_ONE_OF_MANY=This rule requires events to be available from one of the following event types: {0}.
General_TEXT_COULD_NOT_DETERMINE_JAVA_VERSION=The Java version could not be determined.
General_UNKNOWN_ADDRESS=<Unknown Address>
General_UNKNOWN_FILE_NAME=<Unknown File>
HeapContentRule_AGGR_CLASS_SCORE=Class Score
HeapContentRuleFactory_RULE_NAME=Heap Content
HeapContentRuleFactory_TEXT_INFO=Most of the heap was used by only a few classes.
HeapContentRuleFactory_TEXT_INFO_LONG=If the heap usage needs to be reduced, then this would be a good place to start.
HeapContentRuleFactory_TEXT_OK=No problems were found with the heap content.
HeapInspectionGcRuleFactory_RULE_NAME=GCs Caused by Heap Inspection
# {0} is a number
HeapInspectionGcRuleFactory_TEXT_INFO=The JVM performed {0} heap inspection garbage collections.
HeapInspectionGcRuleFactory_TEXT_INFO_LONG=Performing heap inspection garbage collections may be a problem since they usually take a lot of time.
HeapInspectionGcRuleFactory_TEXT_INFO_LONG_JFR=Some of these inspections were caused by the 'Object Count' JFR event. It triggers a full garbage collection at the beginning and end of every recording where that event is enabled. If recordings are only made on demand or not too often, then these garbage collections are usually not a problem since the resulting pauses are not part of the normal application behavior. If recordings are collected often, for example by automatic scripts, or if the application is sensitive to pauses, then it might become an issue. In that case you can consider disabling the 'Object Count' event.
HeapInspectionGcRuleFactory_TEXT_OK=The JVM did not perform any heap inspection GCs.
HeapInspectionGcRuleFactory_TEXT_OK_LONG=The JVM did not perform any heap inspection GCs. This is good since they usually take a lot of time.
HeapInspectionRule_CONFIG_WARNING_LIMIT=Heap inspection GC limit
HeapInspectionRule_CONFIG_WARNING_LIMIT_LONG=Warning limit ratio between number of heap inspection garbage collections and total garbage collections
HighGcRuleFactory_RULE_NAME=GC Pressure
# {0} is a time period, {1} is a time stamp, {2} is a percentage
HighGcRuleFactory_TEXT_INFO=The JVM was paused for {2} of the {0} at {1}.
HighGcRuleFactory_TEXT_INFO_LONG=The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.
HighGcRuleFactory_TEXT_OK=The runtime did not spend much time performing garbage collections.
HighJvmCpuRule_AGGR_MAX_ENDTIME=Max End Time
HighJvmCpuRule_AGGR_MIN_ENDTIME=Min End Time
HighJvmCpuRule_CONFIG_CPU_INFO_LIMIT=JVM CPU usage info limit
HighJvmCpuRule_CONFIG_CPU_INFO_LIMIT_LONG=The amount of CPU used by the JVM needed to trigger an info notice
HighJvmCpuRule_CONFIG_MIN_CPU_LIMIT_LONG=Minimum CPU load period to trigger a warning
HighJvmCpuRule_CONFIG_MIN_CPULOAD=Minimum CPU load period
HighJvmCpuRule_CONFIG_SAMPLE_LIMIT=Missing sample limit
HighJvmCpuRule_CONFIG_SAMPLE_LIMIT_LONG=Minimum missing samples to trigger a warning
HighJvmCpuRule_FEW_SAMPLES=This recording contains few profiling samples even though the CPU load is high.
HighJvmCpuRule_FEW_SAMPLES_LONG=The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.
HighJvmCpuRule_LONG_CPU_LOAD_PERIOD=This recording has a high sampling period for 'CPU Load' events.
# {0} is a time period
HighJvmCpuRule_LONG_CPU_LOAD_PERIOD_LONG=The sampling period for the ''CPU Load'' events was set to {0}, which is too high for CPU load related rules to work.
HighJvmCpuRule_RULE_NAME=High JVM CPU Load
HighJvmCpuRule_TEXT_OK=The JVM does not seem to cause a lot of CPU load.
HighJvmCpuRule_TEXT_WARN=The JVM loads the CPU a lot.
HotMethodsRuleFactory_NOT_ENOUGH_SAMPLES=Could not extract enough execution samples to calculate a score. Try generating more samples, either by increasing the load on your application, lowering the sample period, or extending the recording time.
# {0} is a method name, {1} is a percentage, {2} is a duration of time
HotMethodsRuleFactory_TEXT_INFO=The most sampled method was {0}, with {1} of the maximum possible samples for {2}, and {3} of the actual samples.
# {0} is a list of method names with a percentage and a timespan, {1} is the hottest stack trace
HotMethodsRuleFactory_TEXT_INFO_LONG=The methods that used the most CPU are: {0}<p>Consider optimizing their code.<p> The most common stack trace was: {1}
HotMethodsRuleFactory_TEXT_OK=No methods where optimization would be particularly efficient could be detected.
IgnoreUnrecognizedVMOptionsRuleFactory_TEXT_INFO=The JVM ignored unrecognized VM options.
IgnoreUnrecognizedVMOptionsRuleFactory_TEXT_INFO_LONG=The recording was performed on a JVM that ignored unrecognized VM options, which means that no checking was done on the presence of invalid VM flags. This means that there may be some VM behavior that you think is configured but which is not. This can be because the running VM does not support it, or because the option is misspelled. Unless it is necessary, avoid the '-XX:+IgnoreUnrecognizedVMOptions' command line option.
# {0} is an object type with a field name, {1} is a number, {2} is another object type with a field name
IncreasingLiveSetRule_LOADED_CLASSES_PERCENT=Classes Loaded
IncreasingLiveSetRule_LOADED_CLASSES_PERCENT_DESC=The percentage of loaded classes which indicates that the warm up phase has completed. The rule ignores allocations made before this amount of classes have been loaded.
IncreasingLiveSetRule_TEXT_INFO_BALANCED=There is no particular class that seems to be leaking more than any other.
IncreasingLiveSetRule_TEXT_INFO_LONG=Perform a dump with the 'Trace Paths to GC Roots' option enabled to enable a more detailed analysis of the potential memory leak.
# {0} is a timestamp
IncreasingLiveSetRule_TEXT_INFO_NO_CANDIDATES=Did not find any memory leaks. This may be because all potential candidates are below the configured thresholds. It may also be a false positive due to long-lived allocations occurring after {0}, which is when the rule assumed the application would not allocate large long-lived objects anymore.
IncreasingLiveSetRule_TEXT_INFO_UNBALANCED=There are some classes that seem to leak more than other classes.
IncreasingLiveSetRule_TEXT_OK=No memory leaks were detected.
IncreasingLiveSetRule_RELEVANCE_THRESHOLD=Leak Candidate Relevance Threshold
IncreasingLiveSetRule_RELEVANCE_THRESHOLD_DESC=The calculated relevance threshold to use when determining whether or not a live object is to be considered a memory leak.
IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD=Young Collection Threshold
IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD_DESC=The minimum number of young collections needed in order to evaluate a live set trend.
IncreasingLiveSetRule_CANDIDATE_REFERRED_BY=The candidate is referenced by this chain.
IncreasingLiveSetRule_ELLIPSIS=...
# {0} is a number
IncreasingLiveSetRule_LEAK_CANDIDATES=An analysis of the reference tree found {0} leak candidates.
IncreasingLiveSetRuleFactory_RULE_NAME=Heap Live Set Trend
# {0} is a number denoted in Mebibytes per second
IncreasingLiveSetRuleFactory_TEXT_INFO=The live set on the heap seems to increase with a speed of about {0} per second during the recording.
IncreasingLiveSetRuleFactory_TEXT_INFO_LONG=This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began {0} after the JVM was started. More information can be gathered by using the 'Old Object Sample' event, if available.
IncreasingMetaspaceLiveSetRuleFactory_RULE_NAME=Metaspace Live Set Trend
IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO=The class data seems to increase constantly in the metaspace during the recording.
IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO_LONG=This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.
IncreasingMetaspaceLiveSetRuleFactory_TEXT_OK=The class data does not seem to increase during the recording.
JavaBlocking_RULE_NAME=Java Blocking
JavaBlockingRule_AGGR_BALANCE_BY_INSTANCE=By Instance
JavaBlockingRule_AGGR_BALANCE_BY_THREAD=By Thread
JavaBlockingRule_CONFIG_EXCLUDED_THREADS=Java blocked excluded thread names
JavaBlockingRule_CONFIG_EXCLUDED_THREADS_LONG=Regular expression describing which thread names to exclude, for example '(.*weblogic\\.socket\\.Muxer.*|MyExcludedThreadName)'
# {0} is a regexp exclude string
JavaBlockingRule_TEXT_EXCLUDED_THREADS=The following regular expression was used to exclude threads from this rule: ''{0}''
# {0} is a time period
JavaBlockingRule_TEXT_INFO=Threads in the application were blocked on locks for a total of {0}.
JavaBlockingRule_TEXT_MESSAGE=No excessive problems with lock contention found.
# {0} is a class name, {1} is a number, {2} is a time period
JavaBlockingRule_TEXT_MOST_BLOCKED_CLASS=The most blocking monitor class was ''{0}'', which was blocked {1} times for a total of {2}.
# {0} is a thread name, {1} is a number, {2} is a time period
JavaBlockingRule_TEXT_MOST_BLOCKED_THREAD=The most blocking thread was ''{0}'', which was blocked {1} times for a total of {2}.
JavaBlockingRule_TEXT_OK=No problems with lock contention were found.
LongGcPauseRuleFactory_RULE_NAME=GC Pause Peak Duration
# {0} is a time period
LongGcPauseRuleFactory_TEXT_INFO=The longest GC pause was {0}.
LongGcPauseRuleFactory_TEXT_INFO_G1=You may want to use the G1 garbage collector which is built to reduce garbage collector pauses. To enable G1, add '-XX:+UseG1GC' to the command line.
# {0} is a size in bytes, {1} is a size in bytes
LongGcPauseRuleFactory_TEXT_INFO_MX=The application ran with a live set of {0} and a heap size of {1}. Decreasing the heap size may decrease the garbage collection pause times.
LongGcPauseRuleFactory_TEXT_INFO_REFERENCES=Processing reference objects was a considerable part of the garbage collector pauses. You may be able to decrease this by reducing the amount of references or by enabling parallel reference processing with '-XX:+ParallelRefProcEnabled'.
LongGcPauseRuleFactory_TEXT_OK=The application did not cause any long GC pause times.
LongGcPauseRule_CONFIG_INFO_LIMIT=GC pause warning limit
LongGcPauseRule_CONFIG_INFO_LIMIT_LONG=The GC pause time needed to trigger a warning
LowOnPhysicalMemoryFactory_RULE_NAME=Free Physical Memory
# {0} is a percentage
LowOnPhysicalMemoryFactory_TEXT_INFO=The maximum amount of used memory was {0} of the physical memory available.
# {0} is a size in bytes, {1} is a percentage, {2} is a size in bytes
LowOnPhysicalMemoryFactory_TEXT_INFO_LONG=The maximum amount of memory used was {0}. This is {1} of the {2} of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.
LowOnPhysicalMemoryFactory_TEXT_OK=The system did not run low on physical memory during this recording.
ManagementAgentRule_TEXT_INFO=Management agent settings (port, authentication and/or SSL) were changed during runtime.
ManagementAgentRule_TEXT_INFO_LONG=Management agent settings (port, authentication and/or SSL) were changed during runtime, this is not likely to have had any effect, but could be useful to investigate.
ManagmentAgentRuleFactory_RULE_NAME=Discouraged Management Agent Settings
ManagmentAgentRuleFactory_TEXT_INFO_SSL_DISABLED=Insecure management agent settings: SSL disabled.
ManagmentAgentRuleFactory_TEXT_INFO_SSL_DISABLED_LONG=The runtime management agent settings were insecure. SSL/TLS was disabled. This is discouraged in production systems, since the traffic will not be secure.
ManagmentAgentRuleFactory_TEXT_OK=No problems were found with the management agent settings.
ManagmentAgentRuleFactory_TEXT_WARN_AUTH_DISABLED=Insecure management agent settings: Password authentication disabled.
ManagmentAgentRuleFactory_TEXT_WARN_AUTH_DISABLED_LONG=The runtime management agent settings were insecure. Password authentication was disabled. A remote user who knows (or guesses) the port number and host name will be able to monitor and control the Java application and platform. This is highly discouraged for production systems.
ManagmentAgentRuleFactory_TEXT_WARN_BOTH_DISABLED=Insecure management agent settings: Both password authentication and SSL were disabled.
ManagmentAgentRuleFactory_TEXT_WARN_BOTH_DISABLED_LONG=The runtime management agent settings were insecure. Both password authentication and SSL were disabled. A remote user who knows (or guesses) the port number and host name will be able to monitor and control the Java application and platform. This is highly discouraged for production systems.
ManagmentAgentRuleFactory_TEXT_WARN_CONFIGURE_GUIDE=See the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html">Java Monitoring and Management Guide</a> for more information about how to configure the management agent.
ManyRunningProcessesRule_RULE_NAME=Competing Processes
# {0} is a number, {1} is a time stamp
ManyRunningProcessesRule_TEXT_INFO={0} processes were running while this Flight Recording was made.
# {0} is a number, {1} is a time stamp
ManyRunningProcessesRule_TEXT_INFO_LONG=At {1}, a total of {0} other processes were running on the host machine that this Flight Recording was made on.
ManyRunningProcessesRule_TEXT_RECOMMENDATION=If this is a server environment, it may be good to only run other critical processes on that machine.
ManyRunningProcessesRule_INFO_LIMIT=Competing processes limit
ManyRunningProcessesRule_INFO_LIMIT_LONG=The number of simultaneous processes needed to trigger an info notice
MetaspaceOomRuleFactory_RULE_NAME=Metaspace Out of Memory
MetaspaceOomRuleFactory_TEXT_OK=The metaspace was not exhausted during this recording.
# {0} is a number
MetaspaceOomRuleFactory_TEXT_WARN={0} ''Out of Metaspace Memory'' events are present in this recording.
MetaspaceOomRuleFactory_TEXT_WARN_LONG=Increase or remove the '-XX:MaxMetaSpaceSize' flag or investigate why classes are not unloaded properly.
MethodProfilingDataProvider_AGGR_AGGR_TOP_FRAME_QUOTA=Top Frame Quota
MethodProfilingDataProvider_AGGR_AGGR_TOP_FRAME_QUOTA_DESC=The quota between the top frame and the total samples count
MethodProfilingDataProvider_AGGR_MAX_ENDTIME=Max End Time
MethodProfilingDataProvider_AGGR_MIN_ENDTIME=Min End Time
MethodProfilingDataProvider_AGGR_TOP_FRAME_BALANCE=Top Frame Balance
MethodProfilingDataProvider_AGGR_TOP_FRAME_BALANCE_DESC=The relative balance between stacktrace top frames
MethodProfilingRule_RULE_NAME=Method Profiling
MethodProfilingRule_WINDOW_SIZE=Method profiling window size
MethodProfilingRule_WINDOW_SIZE_DESC=The size of the sliding window to use for evaluating the method profiling samples in this recording. If the evaluation of this rule takes a long time, consider increasing this parameter. Note an increased window size may reduce the accuracy of the rule.
MethodProfilingRule_EXCLUDED_PACKAGES=Packages to exclude from the stack trace
MethodProfilingRule_EXCLUDED_PACKAGES_DESC=The packages to exclude when traversing stack traces. Drop all frames matching the pattern until reaching the first frame not belonging to either. Count the first encountered frame instead as the hot one.
# {0} is a number, {1} is a number
NumberOfGcThreadsRuleFactory_TEXT_INFO=The runtime used {0} GC threads on a machine with {1} CPU cores.
NumberOfGcThreadsRuleFactory_TEXT_INFO_LONG=It's suboptimal to use more GC threads than available cores. Removing the '-XX:ParallelGCThreads' flag will allow the JVM to set the number of GC threads automatically.
ObjectStatisticsDataProvider_AGGR_LIVE_SIZE_INCREASE=Live Size Increase
ObjectStatisticsDataProvider_AGGR_LIVE_SIZE_INCREASE_DESC=The difference in total size from after the first garbage collection to after the last
OptionsCheckRule_CONFIG_ACCEPTED_OPTIONS=Accepted Options
OptionsCheckRule_CONFIG_ACCEPTED_OPTIONS_LONG=The -XX (non validated) JVM option names in this comma separated list will not be checked by the rule
OptionsCheckRule_RULE_NAME=Command Line Options Check
# {0} is a Java version string
OptionsCheckRule_TEXT_DEPRECATED=Deprecated in Java {0}.
# {0} is a Java version string, {1} is a Java version string
OptionsCheckRule_TEXT_DEPRECATED_IGNORED=Deprecated in Java {0} and ignored in Java {1}.
# {0} is a Java version string, {1} is a Java version string, {2} is a Java version string
OptionsCheckRule_TEXT_DEPRECATED_IGNORED_REMOVED=Deprecated in Java {0}, ignored in Java {1}, and removed in Java {2}.
# {0} is a Java version string, {1} is a Java version string
OptionsCheckRule_TEXT_DEPRECATED_REMOVED=Deprecated in Java {0} and removed in Java {1}.
OptionsCheckRule_TEXT_DEPRECATED_WARNING=Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.
# {0} is a Java version string
OptionsCheckRule_TEXT_IGNORED=Ignored in Java {0}.
# {0} is a Java version string, {1} is a Java version string
OptionsCheckRule_TEXT_IGNORED_REMOVED=Ignored in Java {0} and removed in Java {1}.
OptionsCheckRule_TEXT_NA=No events with JVM arguments were recorded.
OptionsCheckRule_TEXT_OK=No undocumented, deprecated or non-recommended option flags were detected.
OptionsCheckRule_TEXT_UNDOC_DEPR_NOTREC=Undocumented, deprecated and non-recommended option flags were detected.
OptionsCheckRule_TEXT_UNDOC_DEPR=Undocumented and deprecated option flags were detected.
OptionsCheckRule_TEXT_UNDOC_NOTREC=Undocumented and non-recommended option flags were detected.
OptionsCheckRule_TEXT_DEPR_NOTREC=Deprecated and non-recommended option flags were detected.
OptionsCheckRule_TEXT_UNDOC=Undocumented option flags were detected.
OptionsCheckRule_TEXT_DEPR=Deprecated option flags were detected.
OptionsCheckRule_TEXT_NOTREC=Non-recommended option flags were detected.
OptionsCheckRule_TEXT_GENERAL_PROBLEM=Option flag problems were detected.
OptionsCheckRule_TEXT_OPTION_DEPRECATED=The following option flag is or will be deprecated.
OptionsCheckRule_TEXT_OPTION_NOT_DOCUMENTED=The following option flag is not documented.
OptionsCheckRule_TEXT_OPTION_NOT_RECOMMENDED=The following option flag is not recommended.
OptionsCheckRule_TEXT_OPTIONS_DEPRECATED=The following option flags are or will be deprecated.
OptionsCheckRule_TEXT_OPTIONS_NOT_DOCUMENTED=The following option flags are not documented.
OptionsCheckRule_TEXT_OPTIONS_NOT_RECOMMENDED=The following option flags are not recommended.
# {0} is a Java version string
OptionsCheckRule_TEXT_REMOVED=Removed in Java {0}.
OptionsCheckRule_TEXT_UNDOCUMENTED_WARNING=Undocumented flags may affect the JVM in ways that are not immediately obvious and may also be removed in future releases without warning.
OptionsCheckRule_TEXT_USE_MAXRAMFRACTION=Use MaxRAMFraction instead
OverAggressiveRecordingSettingRuleFactory_RULE_NAME=Discouraged Recording Settings
OverAggressiveRecordingSettingRuleFactory_RULE_TEXT_OK=No problems were found with the recording settings.
OverAggressiveRecordingSettingRuleFactory_TEXT_INFO=These following event types had no threshold: {0}.
# {0} is a list of event type names
OverAggressiveRecordingSettingRuleFactory_TEXT_INFO_LONG=Event types without threshold can lead to quite a lot of events being generated, possibly translating to higher overhead. If this was not intended, please check the settings in the template for future recordings.
ParGcFewThreadsRuleFactory_TEXT_INFO=The JVM ran with a parallel GC but with only one GC thread.
ParGcFewThreadsRuleFactory_TEXT_INFO_LONG=The JVM ran with a parallel GC but with only one GC thread. This is not optimal. To change number of GC threads, use the command line flag <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html">-XX:ParallelGCThreads=X</a>. When run without the '-XX:ParallelGCThreads' flag, the JVM will use a suitable number of GC threads automatically.
ParallelOnSingleCpuRuleFactory_TEXT_INFO=The runtime used a parallel GC on a single-core machine.
ParallelOnSingleCpuRuleFactory_TEXT_INFO_LONG=The runtime used a parallel GC on a single-core machine. This is not optimal. Use the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html">Serial Collector</a> instead, which is optimized for single-core machines.
VerifyNoneRule_WLS_TEXT_INFO=The application ran WebLogic Server with bytecode verification disabled.
VerifyNoneRule_WLS_TEXT_INFO_LONG=The application ran WebLogic Server with bytecode verification disabled. While not generally recommended, it is considered OK for WLS.
VerifyNoneRule_TEXT_INFO=The application ran with bytecode verification disabled.
VerifyNoneRule_TEXT_INFO_LONG=The application ran with bytecode verification disabled. Disabling bytecode verification is unsafe and should not be done in a production system. If it is not necessary for the application, then don't use '-Xverify:none' or '-noverify' on the command line. See the <a href="https://www.securecoding.cert.org/confluence/display/java/ENV04-J.+Do+not+disable+bytecode+verification">Secure Coding Standard for Java</a>.
VerifyNoneRule_RULE_NAME=Bytecode Verification
VerifyNoneRule_TEXT_OK=The application ran with bytecode verification enabled.
DebugNonSafepointsRule_RULE_NAME=DebugNonSafepoints
DebugNonSafepointsRule_DISABLED_TEXT_INFO=DebugNonSafepoints was explicitly disabled.
DebugNonSafepointsRule_NOT_ENABLED_TEXT_INFO=DebugNonSafepoints was not enabled.
DebugNonSafepointsRule_NOT_ENABLED_TEXT_INFO_LONG=If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. Use the following JVM flags to enable this: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints'. There is a slight performance overhead when enabling these flags. For more information see <a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Thread%20Management|outline">HotSpot Runtime Overview/Thread Management</a>.
DebugNonSafepointsRule_TEXT_OK=DebugNonSafepoints was explicitly enabled.
DebugNonSafepointsRule_IMPLICIT_TEXT_OK=DebugNonSafepoints was implicitly enabled in the JVM version used to create this recording.
DiscouragedGcOptionsRule_RULE_NAME=GC Setup
DiscouragedGcOptionsRule_TEXT_OK=No problems were found with the GC configuration.
DiscouragedVmOptionsRule_RULE_NAME=Discouraged VM Options
DiscouragedVmOptionsRule_TEXT_OK=No problems were found with the VM options.
DiscouragedVmOptionsRule_BOTH_EXPERIMENTAL_AND_IGNORE=The recording was performed on a JVM that both had Experimental VM Options enabled and which ignored unrecognized VM options.
PasswordsInArgsRule_JAVAARGS_TEXT_INFO=The application arguments in the recording may contain passwords.
# {0} is a list of argument strings
PasswordsInArgsRule_JAVAARGS_TEXT_INFO_LONG=The following suspicious application arguments were found in this recording: {0}<p>They may contain passwords. If you do not want to have your passwords directly as arguments to the Java process, there are usually other means to provide them to your software. If you wish to keep using passwords as arguments, but want to be able to share recordings without also sharing the passwords, please disable the ''JVM Information'' event. Note that disabling the ''JVM Information'' event can limit functionality in the Flight Recorder automated analysis.
PasswordsInArgsRule_RULE_NAME=Passwords in Java Arguments
PasswordsInArgsRule_TEXT_OK=The recording does not seem to contain passwords in the application arguments.
PasswordsInEnvironmentRuleFactory_RULE_NAME=Passwords in Environment Variables
PasswordsInEnvironmentRuleFactory_TEXT_INFO=The environment variables in the recording may contain passwords.
# {0} is a list of environment variable names
PasswordsInEnvironmentRuleFactory_TEXT_INFO_LONG=The following suspicious environment variables were found in this recording: {0}<p>They may contain passwords. If you wish to keep having passwords in your environment variables, but want to be able to share recordings without also sharing the passwords, please disable the ''Initial Environment Variable'' event.
PasswordsInEnvironmentRuleFactory_TEXT_OK=The recording does not seem to contain passwords in the environment variables.
PasswordsInSystemPropertiesRule_RULE_NAME=Passwords in System Properties
PasswordsInSystemPropertiesRule_TEXT_INFO=The system properties in the recording may contain passwords.
# {0} is a list of system property names
PasswordsInSystemPropertiesRule_TEXT_INFO_LONG=The following suspicious system properties were found in this recording: {0}<p>They may contain passwords. If you wish to keep having passwords in your system properties, but want to be able to share recordings without also sharing the passwords, please disable the ''Initial System Property'' event.
PasswordsInSystemPropertiesRule_TEXT_OK=The recording does not seem to contain passwords in the system properties.
ReferenceStatisticsType_FINAL_REFERENCES=Final References
ReferenceStatisticsType_PHANTOM_REFERENCES=Phantom References
ReferenceStatisticsType_SOFT_REFERENCES=Soft References
ReferenceStatisticsType_WEAK_REFERENCES=Weak References
SerialGcOnMultiCpuRuleFactory_TEXT_INFO=The Serial collector was used on a multi-core machine.
SerialGcOnMultiCpuRuleFactory_TEXT_INFO_LONG=The JVM used the Serial GC even though it ran on a multi-core machine. Using Concurrent Mark Sweep, G1 or the Parallel GC instead may yield improved GC performance.
SerialOldRuleFactory_TEXT_WARN_CMS=The CMS garbage collector was used, but the JVM had to revert to do a Serial Old Collection.
SerialOldRuleFactory_TEXT_WARN_CMS_LONG=The application used the Concurrent Mark Sweep garbage collector, but the JVM had to revert to a Serial Old Collection, which takes more time. This is because the Concurrent Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html">-XX:CMSInitiatingOccupancyFraction</a>.
SerialOldRuleFactory_TEXT_WARN_G1=The G1 garbage collector was used, but the JVM had to revert to do a Serial Old Collection.
SerialOldRuleFactory_TEXT_WARN_G1_LONG=The JVM used the G1 garbage collector, but had to revert to a Serial Old Collection, which takes more time. This is because the G1 Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of <a href="http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html">-XX:InitiatingHeapOccupancyPercent</a>. This <a href="http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html">G1 tuning article</a> may prove helpful.
SocketReadRule_CONFIG_INFO_LIMIT=Socket read duration info limit
SocketReadRule_CONFIG_INFO_LIMIT_LONG=The shortest socket read duration that should trigger an info notice
SocketReadRule_CONFIG_WARNING_LIMIT=Socket read duration warning limit
SocketReadRule_CONFIG_WARNING_LIMIT_LONG=The shortest socket read duration that should trigger a warning
SocketReadRuleFactory_RULE_NAME=Socket Read Peak Duration
# {0} is a time period
SocketReadRuleFactory_TEXT_OK=No long socket read pauses were found in this recording (the longest was {0}).
SocketReadRuleFactory_TEXT_NO_EVENTS=There are no socket read events in this recording.
SocketReadRuleFactory_TEXT_RMI_NOTE=Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.
# {0} is a time period
SocketReadRuleFactory_TEXT_WARN=There are long socket read pauses in this recording (the longest is {0}).
# {0} is a time period, {1} is a host name, {2} is a size in bytes
SocketReadRuleFactory_TEXT_WARN_LONG=The longest recorded socket read took {0} to read {2} from the host at {1}.
SocketWriteRule_CONFIG_INFO_LIMIT=Socket write duration info limit
SocketWriteRule_CONFIG_INFO_LIMIT_LONG=The shortest socket write duration that should trigger an info notice
SocketWriteRule_CONFIG_WARNING_LIMIT=Socket write duration warning limit
SocketWriteRule_CONFIG_WARNING_LIMIT_LONG=The shortest socket write duration that should trigger a warning
SocketWriteRuleFactory_RULE_NAME=Socket Write Peak Duration
# {0} is a time period
SocketWriteRuleFactory_TEXT_OK=No long socket write pauses were found in this recording (the longest was {0}).
SocketWriteRuleFactory_TEXT_NO_EVENTS=There are no socket write events in this recording.
SocketWriteRuleFactory_TEXT_RMI_NOTE=Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.
# {0} is a time period
SocketWriteRuleFactory_TEXT_WARN=There are long socket write pauses in this recording (the longest is {0}).
# {0} is a time period, {1} is a host name, {2} is a size in bytes
SocketWriteRuleFactory_TEXT_WARN_LONG=The longest recorded socket write took {0} to write {2} to the host at {1}.
StackdepthSettingRule_RULE_NAME=Stackdepth Setting
StackdepthSettingRule_TEXT_INFO=Some stack traces were truncated in this recording.
# {0} is a number, {1} is an empty String or StackdepthSettingRule_TEXT_INFO_LONG_DEFAULT, {2} is a percentage, {3} is an HTML list of event type names
StackdepthSettingRule_TEXT_INFO_LONG=The Flight Recorder is configured with a maximum captured stack depth of {0}. {1}{2} of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the ''-XX:FlightRecorderOptions=stackdepth=&lt;value&gt;'' value.<p>Events of the following types have truncated stack traces:<ul>{3}</ul>
StackdepthSettingRule_TEXT_INFO_LONG_DEFAULT=This is the default depth.
StackdepthSettingRule_TEXT_NA=No events with stack traces were recorded.
StackdepthSettingRule_TEXT_OK=No stack traces were truncated in this recording.
# {0} is an event type name, {1} is a percentage, this is a template that is reused inside <li> tags in the StackdepthSettingRule_TEXT_INFO_LONG {1} parameter
StackdepthSettingRule_TYPE_LIST_TEMPLATE={0} ({1} truncated traces)

StringDeduplicationRule_RULE_NAME=String Deduplication
StringDeduplicationRule_STRING_ARRAY_ALLOCATION_FRAMES=String internal array allocation frames
StringDeduplicationRule_STRING_ARRAY_ALLOCATION_FRAMES_DESC=Comma separated list of frames where the string internal char/byte arrays are allocated.
StringDeduplicationRule_STRING_ARRAY_LIVESET_RATIO_AND_HEAP_USAGE_LIMIT=Heap usage + String internal array live set ratio info limit
StringDeduplicationRule_STRING_ARRAY_LIVESET_RATIO_AND_HEAP_USAGE_LIMIT_DESC=If the heap usage ratio plus the ratio of the string internal char/byte arrays to total liveset exceeds this limit, then an info notice will be triggered.
StringDeduplicationRule_STRING_ARRAY_ALLOCATION_RATIO_AND_HEAP_USAGE_LIMIT=Heap usage + String internal array allocation info limit
StringDeduplicationRule_STRING_ARRAY_ALLOCATION_RATIO_AND_HEAP_USAGE_LIMIT_DESC=If the heap usage ratio plus the ratio of the allocated string internal char/byte arrays to total allocation exceeds this limit, then an info notice will be triggered.
StringDeduplicationRule_RESULT_USE_STRING_DEDUPLICATION_ENABLED=String deduplication is already enabled.
StringDeduplicationRule_RESULT_GC_LONG=String deduplication is only supported when using the G1 (JDK 8u20+) or Shenandoah garbage collectors. If you want to use this feature you can enable G1 by using '-XX:+UseG1GC', or enable Shenandoah by using '-XX:+UseShenandoahGC'.
StringDeduplicationRule_RESULT_DONT_RECOMMEND_STRING_DEDUPLICATION=There is likely no big benefit from enabling string deduplication.
StringDeduplicationRule_RESULT_RECOMMEND_STRING_DEDUPLICATION=Your application might benefit from enabling string deduplication.
# {0} is an event type, # {1} is an event type
StringDeduplicationRule_RESULT_NO_MAX_HEAP_INFO=No information available about the maximum heap size, enable event type {0} or {1} to improve the accuracy of this rule.
StringDeduplicationRule_RESULT_NO_ALLOC_ITEMS=Found no allocation events for the internal arrays in strings. Either the frame filter preference is incorrectly defined, or the stackTrace attribute is not enabled for the allocation events.
# {0} is a percentage
StringDeduplicationRule_RESULT_HEAP_USAGE=The heap is around {0} % full.
# {0} is a percentage, {1} is either 'byte[]' or 'char[]'
StringDeduplicationRule_RESULT_STRING_ARRAY_LIVESET_RATIO=Approximately {0} % of the live set consists of the internal array type of strings (''{1}'' for this JDK version).
# {0} is a percentage, {1} is either 'byte[]' or 'char[]'
StringDeduplicationRule_RESULT_STRING_ARRAY_ALLOCATION_RATIO=Approximately {0} % of all allocations were of internal arrays in strings ({1} for this JDK version).
StringDeduplicationRule_RESULT_LONG_DESCRIPTION=String deduplication is enabled using the JVM flag '-XX:+UseStringDeduplication'. This flag can be used together with the G1 garbage collector in JDK 8u20 or later, or with the Shenandoah garbage collector.<p>To validate if this gives a performance improvement for your application, create flight recordings both with and without string deduplication. For the run with string deduplication enabled, also enable statistics with '-XX:+PrintStringDeduplicationStatistics' for JDK 8 or '-Xlog:stringdedup*=debug' for JDK 9. Check if the heap live set decrease in the recording with string deduplication enabled is larger than the size of the string deduplication metadata table. The size of the metadata table is printed in the statistics output as 'Table/Memory Usage: XX MB'<p>You can read more about string deduplication in the java options documentation or in <a href="https://openjdk.java.net/jeps/192">JEP 192</a>.
SystemGcRule_CONFIG_WARNING_LIMIT=System.gc() ratio limit
SystemGcRule_CONFIG_WARNING_LIMIT_LONG=Warning limit for ratio between System.gc() and total garbage collections
SystemGcRuleFactory_RULE_NAME=GCs Caused by System.gc()
# {0} is a percentage
SystemGcRuleFactory_TEXT_INFO={0} of the garbage collections were caused by System.gc().
SystemGcRuleFactory_TEXT_INFO_LONG=Calling System.gc() can cause unnecessary garbage collections. If you're not sure that you need these calls, consider removing them.<p>If the calls are in libraries where you can't change the source code, you can use the command line flag '-XX:+DisableExplicitGC' to make the JVM ignore all System.gc() calls.
SystemGcRuleFactory_TEXT_OK=No garbage collections were caused by System.gc().
TlabAllocationRatioRuleFactory_RULE_NAME=TLAB Allocation Ratio
# {0} is a percentage
TlabAllocationRatioRuleFactory_TEXT_INFO=The program allocated {0} of the memory outside of TLABs.
TlabAllocationRatioRuleFactory_TEXT_RECOMMEND_LESS_ALLOCATION=Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.
TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE=The program only allocated objects outside of TLABs.
TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE_LONG=The program only allocated objects outside of Thread Local Allocation Buffers (TLABs).
TlabAllocationRatioRuleFactory_TEXT_OK_NO_OUTSIDE=No object allocations outside of TLABs detected.
UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO=The recording was performed on a JVM that had Experimental VM Options enabled.
UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO_LONG=Experimental VM options may be unreliable and should not be used in a production environment. Unless you have to use an experimental option, you should avoid the '-XX:+UnlockExperimentalVMOptions' command line option.
VMOperations_RULE_NAME=VMOperation Peak Duration
VMOperationRule_CONFIG_WARNING_LIMIT=Blocking VM operation duration warning limit
VMOperationRule_CONFIG_WARNING_LIMIT_LONG=The minimum duration for a blocking VM operation needed to trigger a warning
# {0} is a time period
VMOperationRuleFactory_TEXT_OK=No excessively long VM operations were found in this recording (the longest was {0}).
# {0} is a time period
VMOperationRuleFactory_TEXT_WARN=There are long lasting blocking VM operations in this recording (the longest is {0}).
# {0} is a time period, {1} is a time stamp, {2} is a thread name, {3} is a time stamp
VMOperationRuleFactory_TEXT_WARN_LONG=There are long lasting blocking VM operations in this recording. The longest was of type {1} and lasted for {0}. It was initiated from thread ''{2}'' and happened at {3}. <p>VM operations are JVM internal operations. Some VM operations are executed synchronously (i.e. will block the calling thread), and some need to be executed at so called safe points. Safe point polling is a cooperative suspension mechanism that halts byte code execution in the JVM. A VM operation occurring at a safe point will effectively be "stopping the world", meaning that no Java code will be executing in any thread while executing VM operations at that safe point. Long lasting VM operations executing at safe points can decrease the responsiveness of an application. <p>If you do find such VM operations, then the type of operation and its caller thread provide vital information to understand why the VM operation happened. To find more details, check if there is an event in the caller thread intersecting this event time wise. Looking at the stack trace for such an event can help determining what caused it.</p><p>See <a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html">Runtime Overview</a> for further information.</p>
